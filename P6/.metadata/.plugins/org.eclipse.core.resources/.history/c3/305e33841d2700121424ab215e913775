//
// Generated by JTB 1.3.2
//

package visitor;
import dataStructures.*;
import syntaxtree.*;

import java.lang.Thread.State;
import java.lang.reflect.Array;
import java.util.*;


/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class LivenessAnalysis<R> implements GJNoArguVisitor<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
	int endOfMain;
	ControlFlowGraph CFG;
	HashMap<String, ControlFlowGraph> allCFGs;
	int instructionNumber;
	HashMap<String, Integer> labels;
	boolean flag;
	StatementNode presentStatement;
	boolean change = true;
	String currProc = "";
	//ArrayList<Integer> startPointsOfTemps;
	//ArrayList<Integer> endPointsOfTemps;
	
	public LivenessAnalysis(){
		this.allCFGs = new HashMap<String, ControlFlowGraph>();
		this.CFG = new ControlFlowGraph();
		this.instructionNumber = 0;
		this.labels = new HashMap<String, Integer>();
		this.flag = false;
		this.presentStatement = null;
	}
	
	public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() ) {
    	   //Comes here in case if there exists a label. And no other case acc to our grammar.
          labels.put(currProc + "_" + ((Label)n.node).f0.tokenImage, instructionNumber);
    	  return n.node.accept(this);
      }
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   
   public R visit(Goal n) {
      R _ret=null;
      n.f0.accept(this);
      currProc = "MAIN";
      labels.put("MAIN", instructionNumber);
      n.f1.accept(this);
      n.f2.accept(this);
      CFG.blocks.get(instructionNumber-1).removeSuccessor(instructionNumber);
      allCFGs.put("MAIN", this.CFG);
      // The blocks from here are disconnected
      n.f3.accept(this);
      n.f4.accept(this);
      
      for(String s : allCFGs.keySet()){
    	  ControlFlowGraph fg = allCFGs.get(s);
	      for(StatementNode stmt : fg.blocks){
	    	  if(stmt.getTodo()){
	    		  int successor = labels.get(s+"_" + stmt.getLabelToFill());
	    		  stmt.insertSuccessor(successor);
	    		  stmt.setTodo(false);
	    		  //stmt.setLabelToFill(null);
	    	  }
	      }
	      /*
	      System.out.println("-------------------------------------------------");
	      System.out.println(s  + " : ");
	      */
	      fg = computeLiveness(fg);
	      fg = computeLiveRanges(fg);
	      
	      allCFGs.put(s, fg);
	      //fg.printGraph();
	      //System.out.println("-------------------------------------------------");
	      
      }
      return (R)allCFGs;
   }


/**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n) {
      R _ret=null;
      n.f0.accept(this);
      this.CFG = new ControlFlowGraph();
      instructionNumber = 0;
      currProc = n.f0.f0.tokenImage;
      labels.put(currProc+ "_" + n.f0.f0.tokenImage, instructionNumber);
      this.CFG.itsParamsSize = Integer.parseInt(n.f2.f0.tokenImage);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      allCFGs.put(n.f0.f0.tokenImage, this.CFG);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("NOOP", instructionNumber++);
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("ERROR", instructionNumber++);
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("CJUMP", instructionNumber++);
      n.f1.accept(this);
      stmt.insertUse(Integer.parseInt(n.f1.f1.f0.tokenImage));
      n.f2.accept(this);
      //Since we have a label :
      stmt.setTodo(true);
      stmt.setLabelToFill(n.f2.f0.tokenImage);
      //If condition is false it will anyway fall through. So add next instructionNumber as successor:
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("JUMP", instructionNumber++);
      n.f1.accept(this);
      //Since we have a label :
      stmt.setTodo(true);
      stmt.setLabelToFill(n.f1.f0.tokenImage);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("HSTORE", instructionNumber++);
      n.f1.accept(this);
      int useTempNumber = Integer.parseInt(n.f1.f1.f0.tokenImage);
   	  stmt.insertUse(useTempNumber);
      n.f2.accept(this);
      n.f3.accept(this);
      useTempNumber = Integer.parseInt(n.f3.f1.f0.tokenImage);
   	  stmt.insertUse(useTempNumber);
   	  stmt.insertSuccessor(instructionNumber);
   	  CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("HLOAD", instructionNumber++);
      n.f1.accept(this);
      int defTempNumber = Integer.parseInt(n.f1.f1.f0.tokenImage);
      stmt.insertDef(defTempNumber);
      n.f2.accept(this);
      int useTempNumber = Integer.parseInt(n.f2.f1.f0.tokenImage);
      stmt.insertUse(useTempNumber);
      n.f3.accept(this);
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      StatementNode stmt = new StatementNode("MOVE", instructionNumber++);
      int defTempNumber = Integer.parseInt(n.f1.f1.f0.tokenImage);
      stmt.insertDef(defTempNumber);
      presentStatement = stmt;
      flag = true;
      n.f2.accept(this);
      flag = false;
      stmt = presentStatement;
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("PRINT", instructionNumber++);
      presentStatement = stmt;
      flag = true;
      n.f1.accept(this);	//Why is this a Simple Expression still? Shouldn't this be temp?
      assert(n.f1.f0.choice instanceof Temp);
      flag = false;
      stmt = presentStatement;
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);	
      StatementNode stmt = new StatementNode("RETURN", instructionNumber++);
      presentStatement = stmt;
      flag = true;
      n.f3.accept(this);
      flag = false;
      stmt = presentStatement;
      n.f4.accept(this);
      //stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this); //Goes to Simple Expression? Shouldn't this go to temp always?
      Temp tmp = (Temp)n.f1.f0.choice;
      int useTempNumber = Integer.parseInt(tmp.f1.f0.tokenImage);
      presentStatement.insertUse(useTempNumber);
      presentStatement.setContainsCall(true);
      presentStatement.callStackSize = n.f3.size();
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      if(flag == true){
    	  int useTemp = Integer.parseInt(n.f1.f0.tokenImage);
    	  presentStatement.insertUse(useTemp);
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

}
