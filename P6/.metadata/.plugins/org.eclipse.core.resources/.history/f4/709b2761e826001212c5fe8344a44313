//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;

import java.lang.Thread.State;
import java.util.*;

import javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;


import dataStructures.ControlFlowGraph;
import dataStructures.StatementNode;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */


public class LinearScan<R> implements GJNoArguVisitor<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

	HashMap<String, HashMap<Integer, Integer>> registerAllocation;
	HashMap<String, HashMap<Integer, Integer>> stackAllocation;
	static int presentInstructionNumber = 0;
	int stackPointer = 0;
	int stackLocation = 0;	//Should this be GLOBAL ? : TODO
	static String currentProcedure;
	List<Integer> sortedStartPoint;
	List<Integer> sortedEndPoint;
	ArrayList<Integer> active;
	HashMap<Integer, Integer> registerAllotted; //Key : TempNumber, Value : enumeratedVersion of Register allotted
	HashMap<Integer, Integer> locationOnStack;
	ArrayList<Integer> freeRegisters;
	ControlFlowGraph presentCFG;
	HashMap<String, ControlFlowGraph> allCFGs;
	String registers[] = {"t0","t1","t2","t3","t4","t5","t6", "t7","t8", "t9 ","s0","s1","s2","s3","s4", "s5", "s6","s7"};
	static int noOfSpillTemps = 0;
	public LinearScan(HashMap<String, ControlFlowGraph> allCFGs){
		this.allCFGs = allCFGs;
		registerAllocation = new HashMap<String, HashMap<Integer,Integer>>();
		stackAllocation = new HashMap<String, HashMap<Integer,Integer>>();
		presentCFG = new ControlFlowGraph();
		for(String label : allCFGs.keySet()){
			stackLocation = 0;
			presentCFG = allCFGs.get(label);
			this.freeRegisters = new ArrayList<Integer>();
			for(int i = 0 ; i < registers.length ; i++){
				freeRegisters.add(i);
			}
			presentCFG.startPoints = sortHashMap(presentCFG.startPoints);
			presentCFG.endPoints = sortHashMap(presentCFG.endPoints);
			sortedStartPoint = new ArrayList<Integer>(presentCFG.startPoints.keySet());
		    sortedEndPoint = new ArrayList<Integer>(presentCFG.endPoints.keySet());
		    registerAllotted = new HashMap<Integer, Integer>();
		    locationOnStack = new HashMap<Integer, Integer>();
			LinearScanRegisterAllocation();
			registerAllocation.put(label, registerAllotted);
			stackAllocation.put(label, locationOnStack);
			Vector<Integer> calleeSave = new Vector<Integer>();
			for(int regForTemp : registerAllotted.values()){
				if(regForTemp > 10 && !calleeSave.contains(regForTemp)){
					calleeSave.add(regForTemp);
				}
			}
			presentCFG.noOfCalleeSaveRegisters = calleeSave.size();
			presentCFG.toStoreAndLoadCalleeSaveRegisters = calleeSave;
			//Computing info for call stack size, et al.
			for(StatementNode stmt : presentCFG.blocks){
				if(stmt.isContainsCall()){
					if(presentCFG.maxParams < stmt.callStackSize){
						presentCFG.maxParams = stmt.callStackSize;
					}
					if(presentCFG.maxParams > 4){
						presentCFG.maxParamsOnStack = presentCFG.maxParams - 4;
					}
					int callerCount = 0;
					for(int i = 0 ; i < stmt.liveOut.size(); i++) {
				    	  if(registerAllotted.containsKey(stmt.liveOut.get(i))){
				    		  if(registerAllotted.get(stmt.liveOut.get(i)) < 10){
				    			callerCount++;
				    		  }
				    	  }
				    }
					if(presentCFG.maxCallerSaveRegisters < callerCount){
						presentCFG.maxCallerSaveRegisters = callerCount;
					}
				}
			}
			
		}
		
		
		for(String label : registerAllocation.keySet()){
			HashMap<Integer, Integer> regAlloc = registerAllocation.get(label);
			HashMap<Integer, Integer> stAlloc = stackAllocation.get(label);
 		    System.out.println("--------REGISTER ALLOCATION FOR : " + label +  "-------------------");
			System.out.println(regAlloc.entrySet() + " \n" + stAlloc.entrySet());
			System.out.println("----------------------------END---------------------------");
		}
		
	}
	
	/**
	 * 
	 */
	private void LinearScanRegisterAllocation() {
		active = new ArrayList<Integer>();
		for(int i = 0 ; i < sortedStartPoint.size() ; i++){
			ExpireOldIntervals(i);
			if(active.size() == registers.length/*R*/){
				SpillAtInterval(i);
			}
			else{
				int reg = getFreeRegister();
				registerAllotted.put(sortedStartPoint.get(i), reg );
				active.add(sortedStartPoint.get(i));
				sortActive();
				// Sort by increasing end Point now?
				//Collections.sort(active);
			}
		}
	}
	
	private void sortActive(){
		for(int i = 0 ; i < active.size(); i++){
			for(int j = 0; j < i; j++){
				if(presentCFG.endPoints.get(active.get(j)) > presentCFG.endPoints.get(active.get(i))){
					int temp1 = active.get(j);
					int temp2 = active.get(i);
					active.remove(j);
					active.add(j,temp2);
					active.remove(i);
					active.add(i,temp1);
				}
			}
		}
	}
	
	private int getFreeRegister(){
		if(freeRegisters.size() > 0) {
			return freeRegisters.remove(0);
		}
		else return -1;
	}
	/**
	 * @param i
	 */
	private void SpillAtInterval(int interval) {
		int spillTemp = active.get(active.size()-1);
		System.out.println("Spilling : " + spillTemp);
		if(presentCFG.endPoints.get(spillTemp) > presentCFG.endPoints.get(sortedStartPoint.get(interval))){
			registerAllotted.put(sortedStartPoint.get(interval), registerAllotted.get(spillTemp));
			registerAllotted.remove(spillTemp);
			locationOnStack.put(spillTemp,stackLocation++);
			active.remove(active.indexOf(spillTemp));
			active.add(sortedStartPoint.get(interval));
			sortActive();
		}
		else {
			locationOnStack.put(spillTemp,stackLocation++);
		}
	}

	/**
	 * @param i
	 */
	private void ExpireOldIntervals(int interval) {
		for(int j = 0 ; j < active.size(); j++){
			if(presentCFG.endPoints.get(active.get(j)) >= presentCFG.startPoints.get(sortedStartPoint.get(interval))){
				return;
			}
			addFreeRegister(registerAllotted.get(active.get(j)));
			active.remove(j);
			j = j-1;
			sortActive();
		}
	}

	/**
	 * @param integer
	 */
	private void addFreeRegister(int i) {
		freeRegisters.add(i);
		Collections.sort(freeRegisters);
	}

	/* ----- The code for sorting a hashmap is inspired from Stack Overflow-------- */
	public LinkedHashMap<Integer, Integer> sortHashMap(HashMap<Integer, Integer> passedMap) {
	    List<Integer> mapKeys = new ArrayList<Integer>(passedMap.keySet());
	    List<Integer> mapValues = new ArrayList<Integer>(passedMap.values());
	    LinkedHashMap<Integer, Integer> sortedMap = new LinkedHashMap<Integer, Integer>();

	    Collections.sort(mapValues);
	    Collections.sort(mapKeys);

	    Iterator<Integer> it$ = mapValues.iterator();
	    while (it$.hasNext()) {
	        Object val = it$.next();
	        Iterator<Integer> keyIt = mapKeys.iterator();
	        while (keyIt.hasNext()) {
	            Object key = keyIt.next();
	            int comp1 = Integer.parseInt(passedMap.get(key).toString());
	            int comp2 = Integer.parseInt(val.toString());
	            if (comp1 == comp2) {
	                passedMap.remove(key);
	                mapKeys.remove(key);
	                sortedMap.put((Integer) key, (Integer) val);
	                break;
	            }
	        }
	    }
	    return sortedMap;
	}	
	/*-------------------------------------------------------------------------*/
	
	public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() ) {
    	 R no = n.node.accept(this);
    	 System.out.println();
    	 return no;
      }
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n) {
      R _ret=null;
      n.f0.accept(this);
      currentProcedure = n.f0.tokenImage;
      presentCFG = allCFGs.get(currentProcedure);
      registerAllotted = registerAllocation.get(currentProcedure);
      locationOnStack = stackAllocation.get(currentProcedure);
      System.out.printf("MAIN [ 0 ] [ " + (presentCFG.maxCallerSaveRegisters + presentCFG.noOfCalleeSaveRegisters + locationOnStack.values().size()+ presentCFG.maxParamsOnStack + locationOnStack.values().size()) +" ] " +"[ "  + presentCFG.maxParams + " ]\n");
      n.f1.accept(this);
      n.f2.accept(this);
      System.out.println("END ");
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n) {
      R _ret=null;
      //n.f0.accept(this);
      System.out.println();
      presentInstructionNumber = 0;
      currentProcedure = n.f0.f0.tokenImage;
      presentCFG = allCFGs.get(currentProcedure);
      locationOnStack = stackAllocation.get(currentProcedure);
      registerAllotted = registerAllocation.get(currentProcedure);
      System.out.printf(n.f0.f0.tokenImage + " ");
      n.f1.accept(this);
      System.out.printf(n.f1.tokenImage + " ");
      n.f2.accept(this);
      n.f3.accept(this);
      System.out.printf(n.f3.tokenImage+ " ");
      int itsParamsSizeOnStack = presentCFG.itsParamsSize - 4;
      if(itsParamsSizeOnStack < 0) itsParamsSizeOnStack = 0;
      System.out.printf("[ " + (itsParamsSizeOnStack + presentCFG.maxCallerSaveRegisters + presentCFG.noOfCalleeSaveRegisters + locationOnStack.values().size() + presentCFG.maxParamsOnStack) + " ] " + "[ "  + presentCFG.maxParamsOnStack + " ]\n");
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n) {
      R _ret=null;
      System.out.printf("\t");
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.println("NOOP ");
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.println("ERROR ");
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      
      if(registerAllotted.keySet().contains(Integer.parseInt(n.f1.f1.f0.tokenImage))){
    	  String register = registers[registerAllotted.get(Integer.parseInt (n.f1.f1.f0.tokenImage))];
    	  System.out.printf("CJUMP " + register + " ");
      }
      else {
    	  int noOfParams = presentCFG.itsParamsSize - 4;
    	  if(noOfParams < 0) noOfParams = 0;
    	  System.out.println("ALOAD v1 SPILLEDARG " + (presentCFG.noOfCalleeSaveRegisters + noOfParams + locationOnStack.get(Integer.parseInt(n.f1.f1.f0.tokenImage))));
    	  System.out.println("\tCJUMP v1 ");
    	  /*
    	  System.out.println("SPILLED?" + n.f1.f0.tokenImage);
    	  System.out.println("Entry Set : " + locationOnStack.entrySet());
      	*/
      }
      
      //n.f1.accept(this);
      n.f2.accept(this);
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf("JUMP ");
      n.f1.accept(this);
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n) {
      R _ret=null;
      n.f0.accept(this);
      int temp1 = Integer.parseInt(n.f1.f1.f0.tokenImage);
      int temp2 = Integer.parseInt(n.f3.f1.f0.tokenImage);
	  if(registerAllotted.keySet().contains(temp1) && registerAllotted.keySet().contains(temp2)){
		  //Both have registers allotted.
		  String register1 = registers[registerAllotted.get(temp1)];
		  String register2 = registers[registerAllotted.get(temp2)];
		  System.out.printf("HSTORE " + register1 + " " );
		  n.f2.accept(this);
		  System.out.printf(register2 + " ");
	  }
	  else if(registerAllotted.keySet().contains(temp1) && !registerAllotted.keySet().contains(temp2)){
		  String register1 = registers[registerAllotted.get(temp1)];
		  int noOfParams = presentCFG.itsParamsSize-4;
		  if(noOfParams < 0) noOfParams = 0;
		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
		  System.out.println("ALOAD v1 SPILLEDARG " + offset);
		  System.out.printf("\tHSTORE " + register1 + " " );
		  n.f2.accept(this);
		  System.out.printf( "v1 ");
	  }
	  else if(!registerAllotted.keySet().contains(temp1) && registerAllotted.keySet().contains(temp2)){
		  String register2 = registers[registerAllotted.get(temp2)];
		  int noOfParams = presentCFG.itsParamsSize-4;
		  if(noOfParams < 0) noOfParams = 0;
		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
		  System.out.println("ALOAD v1 SPILLEDARG " + offset);
		  System.out.printf("\tHSTORE v1 ");
		  n.f2.accept(this);
		  System.out.printf(register2);
	  }
	  else {
		  int noOfParams = presentCFG.itsParamsSize-4;
		  if(noOfParams < 0) noOfParams = 0;
		  int offset1 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
		  int offset2 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
		  System.out.println("ALOAD v0 SPILLEDARG " + offset1);
		  System.out.println("\tALOAD v1 SPILLEDARG " + offset2);
		  System.out.println("\tHSTORE " + "v0" + " " );
		  n.f2.accept(this);
		  System.out.printf("v1 ");
	  }
      	  //n.f1.accept(this);
	      //n.f2.accept(this);
	      //n.f3.accept(this);
	  System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n) {
      R _ret=null;
      n.f0.accept(this);
      int temp1 = Integer.parseInt(n.f1.f1.f0.tokenImage);
      int temp2 = Integer.parseInt(n.f2.f1.f0.tokenImage);
	  if(registerAllotted.keySet().contains(temp1) && registerAllotted.keySet().contains(temp2)){
		  //Both have registers allotted.
		  String register1 = registers[registerAllotted.get(temp1)];
		  String register2 = registers[registerAllotted.get(temp2)];
		  System.out.printf("HLOAD " + register1 + " " + register2 + " ");
		  n.f3.accept(this);
	  }
	  else if(registerAllotted.keySet().contains(temp1) && !registerAllotted.keySet().contains(temp2)){
		  String register1 = registers[registerAllotted.get(temp1)];
		  int noOfParams = presentCFG.itsParamsSize-4;
		  if(noOfParams < 0) noOfParams = 0;
		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
		  System.out.println("ALOAD v1 SPILLEDARG " + offset);
		  System.out.printf("\tHLOAD " + register1 + " v1 "+ " ");
		  n.f3.accept(this);
	  }
	  else if(!registerAllotted.keySet().contains(temp1) && registerAllotted.keySet().contains(temp2)){
		  String register2 = registers[registerAllotted.get(temp2)];
		  int noOfParams = presentCFG.itsParamsSize-4;
		  if(noOfParams < 0) noOfParams = 0;
		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
		  System.out.println("ALOAD v1 SPILLEDARG " + offset);
		  System.out.printf("\tHLOAD v1 " + register2);
		  n.f3.accept(this);
	  }
	  else {
		  int noOfParams = presentCFG.itsParamsSize-4;
		  if(noOfParams < 0) noOfParams = 0;
		  int offset1 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
		  int offset2 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
		  System.out.println("ALOAD v0 SPILLEDARG " + offset1);
		  System.out.println("\tALOAD v1 SPILLEDARG " + offset2);
		  System.out.printf("\tHLOAD " + "v0 "  + "v1 "+ " ");
		  n.f3.accept(this);
	  }
      	  //n.f1.accept(this);
	      //n.f2.accept(this);
	      //n.f3.accept(this);

      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n) {
      R _ret=null;
      int temp1 = Integer.parseInt(n.f1.f1.f0.tokenImage);
      if(n.f2.f0.choice instanceof Call) {
    	  n.f2.accept(this);
    	  n.f0.accept(this);
    	  if(registerAllotted.containsKey(temp1)){
    		  System.out.printf("\tMOVE ");
        	  n.f1.accept(this);
        	  System.out.printf("v0 ");
    	  }
    	  else {
    		  int noOfParams = presentCFG.itsParamsSize-4;
      		  if(noOfParams < 0) noOfParams = 0;
      		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
      		  n.f2.accept(this);
      		  System.out.printf("ASTORE SPILLEDARG " + offset + " v0");
    	  }
      }
      
      else if( n.f2.f0.choice instanceof HAllocate){
    	  // TODO : Handle spilled case;
    	  System.out.printf("MOVE ");
    	  n.f0.accept(this);
    	  n.f1.accept(this);
    	  n.f2.accept(this);
      }
      
      else if(n.f2.f0.choice instanceof BinOp){
    	  BinOp nPrime = (BinOp)n.f2.f0.choice;
    	  int temp2 = Integer.parseInt(nPrime.f1.f1.f0.tokenImage);
    	  if(nPrime.f2.f0.choice instanceof Temp){
    		Temp tmp = (Temp)nPrime.f2.f0.choice;
    		int temp3 = Integer.parseInt(tmp.f1.f0.tokenImage);
    		if(registerAllotted.containsKey(temp1)){
    			if(registerAllotted.containsKey(temp2)){
    				if(registerAllotted.containsKey(temp3)){
    					System.out.printf("MOVE " + registers[registerAllotted.get(temp1)] + " " );
    	    			nPrime.f0.accept(this);
    	    			System.out.printf(registers[registerAllotted.get(temp2)] + " " + registers[registerAllotted.get(temp3)]);
    				}
    				else {
    					int noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp3);
    	        		System.out.println("ALOAD v1 SPILLEDARG " + offset );
    	        		System.out.printf("\tMOVE " + registers[registerAllotted.get(temp1)] + " " );
    	    			nPrime.f0.accept(this);
    	    			System.out.printf(registers[registerAllotted.get(temp2)] + " v1");
        			}
    			}
    			else {
    				if(registerAllotted.containsKey(temp3)){
    					int noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
    	        		System.out.println("ALOAD v1 SPILLEDARG " + offset );
    	        		System.out.printf("\tMOVE " + registers[registerAllotted.get(temp1)] + " " );
    	    			nPrime.f0.accept(this);
    	    			System.out.printf("v1 " + registers[registerAllotted.get(temp3)] );
        			}
    				else {
    					int noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset3 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp3);
    	        		System.out.println("ALOAD v1 SPILLEDARG " + offset3 );
    	        		noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset2 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
    	        		System.out.println("\tALOAD v0 SPILLEDARG " + offset2 );
    	        		System.out.printf("\tMOVE " + registers[registerAllotted.get(temp1)] + " " );
    	    			nPrime.f0.accept(this);
    	    			System.out.printf("v0 " + "v1 ");
        			}
    			}
    		}
    		else {
    			int temp1Location = presentCFG.itsParamsSize-4;
      		  	if(temp1Location < 0) temp1Location = 0;
      		  	int offset1 = temp1Location + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
      		  
    			if(registerAllotted.containsKey(temp2)){
    				if(registerAllotted.containsKey(temp3)){
    					System.out.printf("MOVE  v0 " );
    	    			nPrime.f0.accept(this);
    					System.out.println(registers[registerAllotted.get(temp2)] + " " + registers[registerAllotted.get(temp3)]);
    					System.out.printf("\tASTORE "+ "SPILLEDARG " + offset1 +  " v0 ");
    				}
    				else {
    					int noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp3);
    	        		System.out.println("ALOAD v1 SPILLEDARG " + offset );
    	        		System.out.printf("\tMOVE v0 " );
    	    			nPrime.f0.accept(this);
    	    			System.out.println(registers[registerAllotted.get(temp2)] + " v1");
    	    			System.out.printf("\tASTORE "+ "SPILLEDARG " + offset1 +  " v0 ");
        			}
    			}
    			else {
    				if(registerAllotted.containsKey(temp3)){
    					int noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
    	        		System.out.println("ALOAD v1 SPILLEDARG " + offset );
    	        		System.out.printf("\tMOVE v0 " );
    	    			nPrime.f0.accept(this);
    	    			System.out.println("v1 " + registers[registerAllotted.get(temp3)] );
    	    			System.out.printf("\tASTORE "+ "SPILLEDARG " + offset1 +  " v0 ");
        				
        			}
    				else {
    					int noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset3 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp3);
    	        		System.out.println("ALOAD v1 SPILLEDARG " + offset3 );
    	        		noOfParams = presentCFG.itsParamsSize-4;
    	        		if(noOfParams < 0) noOfParams = 0;
    	        		int offset2 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
    	        		System.out.println("\tALOAD v0 SPILLEDARG " + offset2 );
    	        		System.out.printf("\tMOVE v0 " );
    	    			nPrime.f0.accept(this);
    	    			System.out.println("v0 " + "v1 ");
    	    			System.out.printf("\tASTORE "+ "SPILLEDARG " + offset1 +  " v0 ");
        			}
    			}
    		}
    	  }	
    	  else if(nPrime.f2.f0.choice instanceof IntegerLiteral){
    			IntegerLiteral l = (IntegerLiteral)nPrime.f2.f0.choice;
    		  		if(registerAllotted.containsKey(temp1)){
        				if(registerAllotted.containsKey(temp2)){
        					System.out.printf("MOVE " + registers[registerAllotted.get(temp1)] + " " );
        	    			nPrime.f0.accept(this);
        					System.out.printf(registers[registerAllotted.get(temp2)] + " ");
        					l.accept(this);
        				}
        				else {
        					int noOfParams = presentCFG.itsParamsSize-4;
        	        		if(noOfParams < 0) noOfParams = 0;
        	        		int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
        	        		System.out.println("ALOAD v1 SPILLEDARG " + offset );
        	        		System.out.printf("\tMOVE " + registers[registerAllotted.get(temp1)] + " " );
        	    			nPrime.f0.accept(this);
        	    			System.out.printf("v1 ");
        	    			l.accept(this);
            			}
        			}
        			else {
        				if(registerAllotted.containsKey(temp2)){
        					int noOfParams = presentCFG.itsParamsSize-4;
        	        		if(noOfParams < 0) noOfParams = 0;
        	        		int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
        	        		System.out.printf("MOVE v0");
        	    			nPrime.f0.f0.accept(this);
        	    			System.out.println("v1 " + registers[registerAllotted.get(temp2)] );
        	    			System.out.printf("\t ASTORE SPILLEDARG " + offset + " v0");
            			}
        				else {
        					int noOfParams = presentCFG.itsParamsSize-4;
        	        		if(noOfParams < 0) noOfParams = 0;
        	        		int offset1 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
        	        		noOfParams = presentCFG.itsParamsSize-4;
        	        		if(noOfParams < 0) noOfParams = 0;
        	        		int offset2 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
        	        		System.out.println("\tALOAD v0 SPILLEDARG " + offset2 );
        	        		System.out.printf("\tMOVE v0 ");
        	    			nPrime.f0.f0.accept(this);
        	    			System.out.println("v0 " + "v1 ");
        	    			System.out.printf("\t ASTORE SPILLEDARG " + offset1 + " v0");
                		}
        			}
        		
    	  }
      }
      
      else {
    	  SimpleExp nPrime = (SimpleExp)n.f2.f0.choice;
    	  if(nPrime.f0.choice instanceof Temp){
    		  Temp l = (Temp)nPrime.f0.choice;
    		  int temp2 = Integer.parseInt(l.f1.f0.tokenImage);
        	  if(registerAllotted.containsKey(temp1) && registerAllotted.containsKey(temp2)) {
    	    	  String temp1Location = registers[registerAllotted.get(temp1)];
    	    	  String temp2Location = registers[registerAllotted.get(temp2)];
    	    	  System.out.printf("MOVE " + temp1Location + " " + temp2Location);
        	  }
        	  else if(registerAllotted.keySet().contains(temp1) && !registerAllotted.keySet().contains(temp2)){
        		  String register1 = registers[registerAllotted.get(temp1)];
        		  int noOfParams = presentCFG.itsParamsSize-4;
        		  if(noOfParams < 0) noOfParams = 0;
        		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
        		  System.out.println("ALOAD v1 SPILLEDARG " + offset);
        		  System.out.printf("\tMOVE " + register1 + " v1 "+ " ");
        	  }
        	  else if(!registerAllotted.keySet().contains(temp1) && registerAllotted.keySet().contains(temp2)){
        		  String register2 = registers[registerAllotted.get(temp2)];
        		  int noOfParams = presentCFG.itsParamsSize-4;
        		  if(noOfParams < 0) noOfParams = 0;
        		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
        		  System.out.printf("ASTORE SPILLEDARG " + offset + " " +  register2);
        	  }
        	  else {
        		  int noOfParams = presentCFG.itsParamsSize-4;
        		  if(noOfParams < 0) noOfParams = 0;
        		  int offset1 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp1);
        		  int offset2 = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(temp2);
        		  System.out.println("ALOAD v1 SPILLEDARG " + offset2);
        		  System.out.printf("\tASTORE SPILLEDARG " + offset1 + " v1");
        	  }
    	  }
    	  
    	  else if(nPrime.f0.choice instanceof IntegerLiteral){
    		  IntegerLiteral l = (IntegerLiteral)nPrime.f0.choice;
    		  if(registerAllotted.containsKey(temp1)) {
    	    	  String temp1Location = registers[registerAllotted.get(temp1)];
    	    	  System.out.printf("MOVE " + temp1Location + " " + l.f0.tokenImage);
        	  }
    	      else {
    	    	  int paramsSize = presentCFG.itsParamsSize-4;
    	    	  if(paramsSize < 0) paramsSize = 0;
    	    	  System.out.println("DEBUG : " + temp1 +" "+ locationOnStack.get(temp1) + registerAllotted.get(temp1) );
    	    	  int temp1Location = locationOnStack.get(temp1) + paramsSize + presentCFG.noOfCalleeSaveRegisters;
    	    	  System.out.println("MOVE v1 "+l.f0.tokenImage);
        	      System.out.printf("ASTORE SPILLEDARG " + temp1Location + " v1");
    	    	}
    	  }
    	  else{
    		  Label l = (Label)nPrime.f0.choice;
    		  if(registerAllotted.containsKey(temp1)) {
    	    	  String temp1Location = registers[registerAllotted.get(temp1)];
    	    	  System.out.printf("MOVE " + temp1Location + " " + l.f0.tokenImage);
        	  }
    	      else {
    	    	  int paramsSize = presentCFG.itsParamsSize-4;
    	    	  if(paramsSize < 0) paramsSize = 0;
    	    	  int temp1Location = locationOnStack.get(temp1) + paramsSize + presentCFG.noOfCalleeSaveRegisters;
    	    	  System.out.println("MOVE v1 "+l.f0.tokenImage);
        	      System.out.printf("ASTORE SPILLEDARG " + temp1Location + " v1");
    	      }
    	  }
      }
      /*
      if(!(n.f2.f0.choice instanceof Call)){
	      n.f0.accept(this);
	      System.out.printf("MOVE ");
	      //n.f1.accept(this);
	      if(registerAllotted.keySet().contains(Integer.parseInt(n.f1.f1.f0.tokenImage))){
	    	  String register = registers[registerAllotted.get(Integer.parseInt (n.f1.f1.f0.tokenImage))];
	    	  System.out.printf(register + " ");
	      }
	      else {
	    	  //TODO : Position on the stack as it is being spilled.
	    	  System.out.println("SPILLED?" + n.f1.f1.f0.tokenImage);
	    	  System.out.println("Entry Set : " + locationOnStack.entrySet());
	      }
	      boolean flag = true;
	      if(n.f2.f0.choice instanceof SimpleExp){
	    	  SimpleExp node = (SimpleExp)n.f2.f0.choice;
	    	  if(node.f0.choice instanceof Label){
	    		  flag = false;
	    		  Label l = (Label)node.f0.choice;
	    		  System.out.printf(l.f0.tokenImage);
	    	  }
	      }
	      if(flag == true){
	    	  n.f2.accept(this);
	    	  n.f0.accept(this);
	      }
      }
      else {
    	  n.f2.accept(this);
    	  n.f0.accept(this);
    	  System.out.printf("\tMOVE ");
    	  n.f1.accept(this);
    	  System.out.printf("v0 ");
      }*/
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n) {
      R _ret=null;
      n.f0.accept(this);
      if(n.f1.f0.choice instanceof Label){
    	  System.out.printf("PRINT ");
          Label l = (Label)n.f1.f0.choice;
		  System.out.println(l.f0.tokenImage);
	  }
      else if(n.f1.f0.choice instanceof Temp) {
    	  Temp tmp = (Temp)n.f1.f0.choice;
    	  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    	  if(registerAllotted.containsKey(tempNo)){
    		  System.out.printf("PRINT " + registers[registerAllotted.get(tempNo)]);
    	  }
    	  else {
    		  int noOfParams = presentCFG.itsParamsSize-4;
    		  if(noOfParams < 0) noOfParams = 0;
    		  int offset = noOfParams + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(tempNo);
    		  System.out.println("ALOAD v0 SPILLEDARG " + offset );
    		  System.out.printf("\tPRINT v0");
    	  }
      }
      else {
    	  System.out.printf("PRINT ");
    	  n.f1.accept(this);
      }
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = presentCFG.blocks.get(presentInstructionNumber);
      int k = 0;
      int paramsOnStack = presentCFG.itsParamsSize - 4;
      if(paramsOnStack < 0) paramsOnStack = 0;
      for(int toStore : presentCFG.toStoreAndLoadCalleeSaveRegisters){
    	  if(k==0) System.out.println("ASTORE SPILLEDARG " + (paramsOnStack + (k++)) + " " + registers[toStore]);
    	  else System.out.println("\tASTORE SPILLEDARG " + (paramsOnStack + (k++)) + " " + registers[toStore]);
    	  
      }
      for(int i = 0; i < stmt.liveIn.size(); i++){
    	if(stmt.liveIn.get(i) < 4) {
    		if(registerAllotted.containsKey(stmt.liveIn.get(i))){
	    		System.out.println("\tMOVE "+ registers[registerAllotted.get(stmt.liveIn.get(i))] + " a"+ stmt.liveIn.get(i));
	    	}
	    	else{
	    		int offset = paramsOnStack + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(stmt.liveIn.get(i));
	    		System.out.println("\tMOVE v1 a"+ stmt.liveIn.get(i));
	    		System.out.println("\tASTORE SPILLEDARG "+ offset +" v1");
	    	}
    	}
    	else{
    		if(registerAllotted.containsKey(stmt.liveIn.get(i))){
    			System.out.println("\tALOAD " + "v1" + " SPILLEDARG "+ (stmt.liveIn.get(i)-4));
	    		System.out.println("\tMOVE "+ registers[registerAllotted.get(stmt.liveIn.get(i))] + " v1 ");
	    	}
    		else {
    			int offset = paramsOnStack + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(stmt.liveIn.get(i));
	    		System.out.println("\tALOAD " + "v1" + " SPILLEDARG "+ (stmt.liveIn.get(i)-4));
    			System.out.println("\tASTORE SPILLEDARG "+ offset +" v1");
    	    }
	    }
      }
      n.f1.accept(this);
      n.f2.accept(this);
      if(n.f3.f0.choice instanceof Temp){
    	  Temp tmp = (Temp)n.f3.f0.choice;
    	  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    	  if(registerAllotted.containsKey(tempNo)){
    	      System.out.printf("\tMOVE v0 ");
    	      n.f3.accept(this);
    	  }
    	  else{
    		  int offset = paramsOnStack + presentCFG.noOfCalleeSaveRegisters + locationOnStack.get(tempNo);
    		  System.out.println("ALOAD v0 SPILLEDARG "+offset );
    	  }
      }
      else {
	      System.out.printf("\tMOVE v0 ");
	      n.f3.accept(this);
	  }
      k = 0;
      for(int toLoad : presentCFG.toStoreAndLoadCalleeSaveRegisters){
    	  System.out.println("\tALOAD " + registers[toLoad] + " SPILLEDARG "+  (paramsOnStack + (k++)) );
      }
      
      System.out.println("\nEND ");
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n) {
      R _ret=null;
      noOfSpillTemps = 0;
      int numberOfParameters = n.f3.size();
      Vector<Node> params = n.f3.nodes;
      StatementNode stmt = presentCFG.blocks.get(presentInstructionNumber);
      int check = 0;
      int paramsOnStack = presentCFG.itsParamsSize - 4;
      if(paramsOnStack < 4) paramsOnStack = 0;
      //TODO : Calculate offset properly based on the number of spilled args right now. Don't store it from the end!
      int offset = paramsOnStack + presentCFG.noOfCalleeSaveRegisters + locationOnStack.keySet().size() + presentCFG.maxCallerSaveRegisters;
      for(int i = 0 ; i < stmt.liveOut.size(); i++) {
    	  if(registerAllotted.containsKey(stmt.liveOut.get(i))){
    		  if(registerAllotted.get(stmt.liveOut.get(i)) < 10){
    			  if(check == 0)
    			  System.out.println("ASTORE SPILLEDARG " + (offset - i - 1) +" "+ registers[registerAllotted.get(stmt.liveOut.get(i))] + " ");
    			  else System.out.println("\tASTORE SPILLEDARG " + (offset- i - 1) +" "+ registers[registerAllotted.get(stmt.liveOut.get(i))] + " ");
    			   check++;
    		  }
    	  }
      }
   if(numberOfParameters < 4){
    	  for(int i = 0 ; i < numberOfParameters; i++){
    		  Temp tmp = (Temp) params.get(i);
    		  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    		  if(registerAllotted.containsKey(tempNo)){
    			  System.out.println("\tMOVE a"+ i + " " + registers[registerAllotted.get(tempNo)]);
    		  }
    		  else {
    			  System.out.println("ALOAD v1 SPILLEDARG " + (paramsOnStack+presentCFG.noOfCalleeSaveRegisters+locationOnStack.get(tempNo)));
    			  System.out.println("\tMOVE a"+i + " v1" );
    		  }
    	  }
      }
      else {
    	  for(int i = 0 ; i < 4; i++){
    		  Temp tmp = (Temp) params.get(i);
    		  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    		  if(registerAllotted.containsKey(tempNo)){
    			  System.out.println("\tMOVE a"+ i + " " + registers[registerAllotted.get(tempNo)]);
    		  }
    		  else {
    			  System.out.println("ALOAD v1 SPILLEDARG " + (paramsOnStack+presentCFG.noOfCalleeSaveRegisters+locationOnStack.get(tempNo)));
    			  System.out.println("\tMOVE a"+i + " v1" );
    		 }
    	  }
    	  for(int i = 4; i < numberOfParameters; i++){
    		  Temp tmp = (Temp) params.get(i);
    		  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    		  if(registerAllotted.containsKey(tempNo)){
    			  System.out.println("\tPASSARG "+ (i-3) + " " + registers[registerAllotted.get(tempNo)]);
    		  }
    		  else {
    			  //TODO : Spilled case
    			  System.out.println("ALOAD v1 SPILLEDARG " + (paramsOnStack+presentCFG.noOfCalleeSaveRegisters+locationOnStack.get(tempNo)));
    			  System.out.println("\tPASSARG " + (i-3) + " v1");
    		  }
    	  }
      }
      n.f0.accept(this);
      if(n.f1.f0.choice instanceof Temp) {
    	  Temp tmp = (Temp)n.f1.f0.choice;
    	  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    	  if(registerAllotted.containsKey(tempNo)){
    		  System.out.println("\tCALL " + registers[registerAllotted.get(tempNo)]);
    	  }
    	  else {
    		  System.out.println("ALOAD v1 SPILLEDARG " + (paramsOnStack+presentCFG.noOfCalleeSaveRegisters+locationOnStack.get(tempNo)));
    		  System.out.println("\tCALL v1");
    	  }
      }
      else {
	      System.out.printf("\tCALL ");
	      n.f1.accept(this);
	  }
      System.out.println();
      n.f2.accept(this);
      //n.f3.accept(this);
      n.f4.accept(this);
      
      for(int i = 0 ; i < stmt.liveOut.size(); i++) {
    	  if(registerAllotted.containsKey(stmt.liveOut.get(i))){
    		  if(registerAllotted.get(stmt.liveOut.get(i)) < 10){
    			  System.out.println("\tALOAD " + registers[registerAllotted.get(stmt.liveOut.get(i))] + " SPILLEDARG " + (offset - i - 1) + " ");
    		  }
    	  }
      }
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n) {
      R _ret=null;
      n.f0.accept(this);
      if(n.f1.f0.choice instanceof Temp) {
    	  Temp tmp = (Temp)n.f1.f0.choice;
    	  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    	  if(registerAllotted.containsKey(tempNo)){
    		  System.out.printf("HALLOCATE " + registers[registerAllotted.get(tempNo)]);
    	  }
    	  else {
    		  int paramsOnStack = presentCFG.itsParamsSize - 4;
    		  if(paramsOnStack < 0) paramsOnStack = 0;
    		  System.out.printf("ALOAD v1 SPILLEDARG " + (paramsOnStack+presentCFG.noOfCalleeSaveRegisters+locationOnStack.get(tempNo)));
    		  System.out.println("HALLOCATE v1 ");
    	  }
      }
      else {
	      System.out.printf("HALLOCATE ");
	      n.f1.accept(this);
	  }
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n) {
      R _ret=null;
      n.f0.accept(this);
      if(n.f0.which == 0) System.out.printf("LT ");
      else if(n.f0.which == 1) System.out.printf("PLUS ");
      else if(n.f0.which == 2) System.out.printf("MINUS ");
      else if(n.f0.which == 3) System.out.printf("TIMES ");
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n) {
      R _ret=null;
      n.f0.accept(this);
      //n.f1.accept(this);
      /* Now comes here only if register is allotted. Actually it hardly comes here. We check for this on top itself */
      if(registerAllotted.keySet().contains(Integer.parseInt(n.f1.f0.tokenImage))){
    	  String register = registers[registerAllotted.get(Integer.parseInt (n.f1.f0.tokenImage))];
    	  System.out.printf(register + " ");
      }
      else {
    	  //TODO : Position on the stack as it is being spilled.
    	  System.out.println("SPILLED?" + n.f1.f0.tokenImage);
    	  System.out.println("Entry Set : " + locationOnStack.entrySet());
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf(n.f0.tokenImage + " ");
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf(currentProcedure + "_" + n.f0.tokenImage + " ");
      return _ret;
   }

}
