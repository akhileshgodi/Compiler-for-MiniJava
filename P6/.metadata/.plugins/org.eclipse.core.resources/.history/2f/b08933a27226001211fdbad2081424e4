//
// Generated by JTB 1.3.2
//

package visitor;
import dataStructures.*;
import syntaxtree.*;

import java.lang.Thread.State;
import java.lang.reflect.Array;
import java.util.*;


/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class LivenessAnalysis<R> implements GJNoArguVisitor<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
	int endOfMain;
	ControlFlowGraph CFG;
	HashMap<String, ControlFlowGraph> allCFGs;
	int instructionNumber;
	HashMap<String, Integer> labels;
	boolean flag;
	StatementNode presentStatement;
	boolean change = true;
	String currProc = "";
	//ArrayList<Integer> startPointsOfTemps;
	//ArrayList<Integer> endPointsOfTemps;
	
	public LivenessAnalysis(){
		this.allCFGs = new HashMap<String, ControlFlowGraph>();
		this.CFG = new ControlFlowGraph();
		this.instructionNumber = 0;
		this.labels = new HashMap<String, Integer>();
		this.flag = false;
		this.presentStatement = null;
	}
	
	public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() ) {
    	   //Comes here in case if there exists a label. And no other case acc to our grammar.
          labels.put(currProc + "_" + ((Label)n.node).f0.tokenImage, instructionNumber);
    	  return n.node.accept(this);
      }
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   
   public R visit(Goal n) {
      R _ret=null;
      n.f0.accept(this);
      currProc = "MAIN";
      labels.put("MAIN", instructionNumber);
      n.f1.accept(this);
      n.f2.accept(this);
      CFG.blocks.get(instructionNumber-1).removeSuccessor(instructionNumber);
      endOfMain = instructionNumber-1;
      allCFGs.put("MAIN", this.CFG);
      // The blocks from here are disconnected
      n.f3.accept(this);
      n.f4.accept(this);
      for(String s : allCFGs.keySet()){
    	  ControlFlowGraph fg = allCFGs.get(s);
	      for(StatementNode stmt : fg.blocks){
	    	  if(stmt.getTodo()){
	    		  int successor = labels.get(s+"_" + stmt.getLabelToFill());
	    		  stmt.insertSuccessor(successor);
	    		  stmt.setTodo(false);
	    		  //stmt.setLabelToFill(null);
	    	  }
	      }
	      /*
	      System.out.println("-------------------------------------------------");
	      System.out.println(s  + " : ");
	      */
	      fg = computeLiveness(fg);
	      fg = computeLiveRanges(fg);
	      
	      allCFGs.put(s, fg);
	      //fg.printGraph();
	      //System.out.println("-------------------------------------------------");
	      
      }
      return (R)allCFGs;
   }

private ControlFlowGraph computeLiveRanges(ControlFlowGraph fg) {
	// TODO Auto-generated method stub
	for(StatementNode stmt : fg.blocks){
		// For live Ins
		for(int i = 0 ; i < stmt.liveIn.size(); i++){
			int tempNo = stmt.liveIn.get(i);
			if(!fg.endPoints.containsKey(tempNo)){
				fg.endPoints.put(tempNo, stmt.getInstructionNumber());
			}
			else {
				int endPt = fg.endPoints.get(tempNo);
				if(stmt.getInstructionNumber() > endPt){
					fg.endPoints.put(tempNo,stmt.getInstructionNumber());
				}
			}
		}
		
		//For live outs
		for(int i = 0 ; i < stmt.liveOut.size(); i++){
			int tempNo = stmt.liveOut.get(i);
			if(!fg.startPoints.containsKey(tempNo)){
				fg.startPoints.put(tempNo, stmt.getInstructionNumber());
			}
			else {
				int startPt = fg.startPoints.get(tempNo);
				if(stmt.getInstructionNumber() < startPt){
					fg.endPoints.put(tempNo, stmt.getInstructionNumber());
				}
			}
		}
		
		for(int i : stmt.getDef()){
			if(!stmt.liveIn.contains(i) && !stmt.liveOut.contains(i)) {
				if(!fg.startPoints.containsKey(i)){
					fg.startPoints.put(i, stmt.getInstructionNumber());
				}
				else {
					fg.endPoints.put(i, stmt.getInstructionNumber());
				}
			}
		}
		
		for(int i : fg.endPoints.keySet()){
			if(!fg.startPoints.containsKey(i)){
				fg.startPoints.put(i, fg.endPoints.get(i));
			}
		}
		
		for(int i : fg.startPoints.keySet()){
			if(!fg.endPoints.containsKey(i)){
				fg.endPoints.put(i, fg.startPoints.get(i));
			}
		}
	}
	return fg;
}

	/**
	 * 
	 */
	private ControlFlowGraph computeLiveness(ControlFlowGraph fg) {
		// TODO Auto-generated method stub
		//System.out.println("Liveness");
		//System.out.printf(" : "  + fg.blocks.size() + "\n");
		change = true;
		while(change) {
			change = false;
			for(int i = fg.blocks.size()-1 ; i >= 0  ; i--){
				StatementNode stmt = fg.blocks.get(i);
				//System.out.println(stmt.statementType);
				//stmt.inPrime = stmt.getLiveIn();
				//stmt.outPrime = stmt.getLiveOut();
				//System.out.println(stmt.getSuccessors().size());
				for(int j = 0; j < stmt.getSuccessors().size(); j++) {
					StatementNode succJ = fg.blocks.get(stmt.getSuccessors().get(j));
					listMergerFromTo(succJ.liveIn, stmt.liveOut);
				}
				
				ArrayList<Integer> outMinusDef = ListDifference(stmt.liveOut, stmt.getDef());
				ListUnion(stmt.getUse(),outMinusDef,stmt.liveIn);
			}
		}
		return fg;
	}

/**
	 * @param liveIn
	 * @param liveOut
	 */
	private void listMergerFromTo(ArrayList<Integer> lst1, ArrayList<Integer> lst2) {
		// TODO Auto-generated method stub
		for(int i = 0; i < lst1.size(); i++) {
			if(!lst2.contains(lst1.get(i))) {
				lst2.add(lst1.get(i));
				change = true;
			}
		}
	}

/**
	 * @return
	 */
	/*
	private boolean noChange() {
		// TODO Auto-generated method stub
		for(int i = 0 ; i < CFG.blocks.size(); i++){
			StatementNode stmt = CFG.blocks.get(i);
			if(stmt.inPrime.equals(stmt.getLiveIn()) && stmt.outPrime.equals(stmt.getLiveOut())){
				return false;
			}
		}
		return true;
	}*/

/**
	 * @param use
	 * @param listDifference
	 * @return
	 */
	private void ListUnion(ArrayList<Integer> lst1, ArrayList<Integer> lst2, ArrayList<Integer>result) {
		// TODO Auto-generated method stub
		for(int i = 0; i < lst1.size(); i++) {
			if(!result.contains(lst1.get(i))) {
				result.add(lst1.get(i));
				change = true;
			}
		}
		for(int i = 0; i < lst2.size(); i++) {
			if(!result.contains(lst2.get(i))) {
				result.add(lst2.get(i));
				change = true;
			}
		}
	}

/**
	 * @param liveOut
	 * @param def
	 * @return
	 */
	private ArrayList<Integer> ListDifference(ArrayList<Integer> lst1, ArrayList<Integer> lst2) {
		// TODO Auto-generated method stub
		ArrayList<Integer> result = new ArrayList<Integer>();
		for(int i = 0; i < lst1.size(); i++) {
			if(!lst2.contains(lst1.get(i))) {
				result.add(lst1.get(i));
			}
		}
		return result;
	}

/**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n) {
      R _ret=null;
      n.f0.accept(this);
      this.CFG = new ControlFlowGraph();
      instructionNumber = 0;
      currProc = n.f0.f0.tokenImage;
      labels.put(currProc+ "_" + n.f0.f0.tokenImage, instructionNumber);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      allCFGs.put(n.f0.f0.tokenImage, this.CFG);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("NOOP", instructionNumber++);
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("ERROR", instructionNumber++);
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("CJUMP", instructionNumber++);
      n.f1.accept(this);
      stmt.insertUse(Integer.parseInt(n.f1.f1.f0.tokenImage));
      n.f2.accept(this);
      //Since we have a label :
      stmt.setTodo(true);
      stmt.setLabelToFill(n.f2.f0.tokenImage);
      //If condition is false it will anyway fall through. So add next instructionNumber as successor:
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("JUMP", instructionNumber++);
      n.f1.accept(this);
      //Since we have a label :
      stmt.setTodo(true);
      stmt.setLabelToFill(n.f1.f0.tokenImage);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("HSTORE", instructionNumber++);
      n.f1.accept(this);
      int useTempNumber = Integer.parseInt(n.f1.f1.f0.tokenImage);
   	  stmt.insertUse(useTempNumber);
      n.f2.accept(this);
      n.f3.accept(this);
      useTempNumber = Integer.parseInt(n.f3.f1.f0.tokenImage);
   	  stmt.insertUse(useTempNumber);
   	  stmt.insertSuccessor(instructionNumber);
   	  CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("HLOAD", instructionNumber++);
      n.f1.accept(this);
      int defTempNumber = Integer.parseInt(n.f1.f1.f0.tokenImage);
      stmt.insertDef(defTempNumber);
      n.f2.accept(this);
      int useTempNumber = Integer.parseInt(n.f2.f1.f0.tokenImage);
      stmt.insertUse(useTempNumber);
      n.f3.accept(this);
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      StatementNode stmt = new StatementNode("MOVE", instructionNumber++);
      int defTempNumber = Integer.parseInt(n.f1.f1.f0.tokenImage);
      stmt.insertDef(defTempNumber);
      presentStatement = stmt;
      flag = true;
      n.f2.accept(this);
      flag = false;
      stmt = presentStatement;
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = new StatementNode("PRINT", instructionNumber++);
      presentStatement = stmt;
      flag = true;
      n.f1.accept(this);	//Why is this a Simple Expression still? Shouldn't this be temp?
      assert(n.f1.f0.choice instanceof Temp);
      flag = false;
      stmt = presentStatement;
      stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);	
      StatementNode stmt = new StatementNode("RETURN", instructionNumber++);
      presentStatement = stmt;
      flag = true;
      n.f3.accept(this);
      flag = false;
      stmt = presentStatement;
      n.f4.accept(this);
      //stmt.insertSuccessor(instructionNumber);
      CFG.insertBlock(stmt);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this); //Goes to Simple Expression? Shouldn't this go to temp always?
      Temp tmp = (Temp)n.f1.f0.choice;
      int useTempNumber = Integer.parseInt(tmp.f1.f0.tokenImage);
      presentStatement.insertUse(useTempNumber);
      presentStatement.setContainsCall(true);
      if(CFG.maxParams < n.f3.size()){
    	  CFG.maxParams = n.f3.size();
      }
      if(CFG.maxParams > 4){
    	  CFG.maxParamsOnStack = CFG.maxParams - 4;
      }
      System.out.println("Maximum parameters : ");
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      if(flag == true){
    	  int useTemp = Integer.parseInt(n.f1.f0.tokenImage);
    	  presentStatement.insertUse(useTemp);
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

}
