//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;

import java.lang.Thread.State;
import java.util.*;

import javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;


import dataStructures.ControlFlowGraph;
import dataStructures.StatementNode;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */


public class LinearScan<R> implements GJNoArguVisitor<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

	HashMap<String, HashMap<Integer, Integer>> registerAllocation;
	HashMap<String, HashMap<Integer, Integer>> stackAllocation;
	static int presentInstructionNumber = 0;
	int stackPointer = 0;
	int stackLocation = 0;	//Should this be GLOBAL ? : TODO
	static String currentProcedure;
	List<Integer> sortedStartPoint;
	List<Integer> sortedEndPoint;
	ArrayList<Integer> active;
	HashMap<Integer, Integer> registerAllotted; //Key : TempNumber, Value : enumeratedVersion of Register allotted
	HashMap<Integer, Integer> locationOnStack;
	ArrayList<Integer> freeRegisters;
	ControlFlowGraph presentCFG;
	HashMap<String, ControlFlowGraph> allCFGs;
	String registers[] = {"t0","t1","t2","t3","t4","t5","t6", "t7","t8", "t9 ","s0","s1","s2","s3","s4", "s5", "s6","s7"};
	static int noOfSpillTemps = 0;
	public LinearScan(HashMap<String, ControlFlowGraph> allCFGs){
		this.allCFGs = allCFGs;
		registerAllocation = new HashMap<String, HashMap<Integer,Integer>>();
		stackAllocation = new HashMap<String, HashMap<Integer,Integer>>();
		presentCFG = new ControlFlowGraph();
		for(String label : allCFGs.keySet()){
			stackLocation = 0;
			presentCFG = allCFGs.get(label);
			this.freeRegisters = new ArrayList<Integer>();
			for(int i = 0 ; i < registers.length ; i++){
				freeRegisters.add(i);
			}
			presentCFG.startPoints = sortHashMap(presentCFG.startPoints);
			presentCFG.endPoints = sortHashMap(presentCFG.endPoints);
			sortedStartPoint = new ArrayList<Integer>(presentCFG.startPoints.keySet());
		    sortedEndPoint = new ArrayList<Integer>(presentCFG.endPoints.keySet());
		    registerAllotted = new HashMap<Integer, Integer>();
		    locationOnStack = new HashMap<Integer, Integer>();
			LinearScanRegisterAllocation();
			registerAllocation.put(label, registerAllotted);
			stackAllocation.put(label, locationOnStack);
			Vector<Integer> calleeSave = new Vector<Integer>();
			for(int regForTemp : registerAllotted.values()){
				if(regForTemp > 10 && !calleeSave.contains(regForTemp)){
					calleeSave.add(regForTemp);
				}
			}
			presentCFG.noOfCalleeSaveRegisters = calleeSave.size();
			presentCFG.toStoreAndLoadCalleeSaveRegisters = calleeSave;
			//Computing info for call stack size, et al.
			for(StatementNode stmt : presentCFG.blocks){
				if(stmt.isContainsCall()){
					if(presentCFG.maxParams < stmt.callStackSize){
						presentCFG.maxParams = stmt.callStackSize;
					}
					if(presentCFG.maxParams > 4){
						presentCFG.maxParamsOnStack = presentCFG.maxParams - 4;
					}
					int callerCount = 0;
					for(int i = 0 ; i < stmt.liveOut.size(); i++) {
				    	  if(registerAllotted.containsKey(stmt.liveOut.get(i))){
				    		  if(registerAllotted.get(stmt.liveOut.get(i)) < 10){
				    			callerCount++;
				    		  }
				    	  }
				    }
					if(presentCFG.maxCallerSaveRegisters < callerCount){
						presentCFG.maxCallerSaveRegisters = callerCount;
					}
				}
			}
			
		}
		
		/*
		for(String label : registerAllocation.keySet()){
			HashMap<Integer, Integer> regAlloc = registerAllocation.get(label);
		    System.out.println("--------REGISTER ALLOCATION FOR : " + label +  "-------------------");
			System.out.println(regAlloc.entrySet());
			System.out.println("----------------------------END---------------------------");
		}*/
		
	}
	
	/**
	 * 
	 */
	private void LinearScanRegisterAllocation() {
		active = new ArrayList<Integer>();
		for(int i = 0 ; i < sortedStartPoint.size() ; i++){
			ExpireOldIntervals(i);
			if(active.size() == registers.length/*R*/){
				SpillAtInterval(i);
			}
			else{
				int reg = getFreeRegister();
				registerAllotted.put(sortedStartPoint.get(i), reg );
				active.add(sortedStartPoint.get(i));
				sortActive();
				// Sort by increasing end Point now?
				//Collections.sort(active);
			}
		}
	}
	
	private void sortActive(){
		for(int i = 0 ; i < active.size(); i++){
			for(int j = 0; j < i; j++){
				if(presentCFG.endPoints.get(active.get(j)) > presentCFG.endPoints.get(active.get(i))){
					int temp1 = active.get(j);
					int temp2 = active.get(i);
					active.remove(j);
					active.add(j,temp2);
					active.remove(i);
					active.add(i,temp1);
				}
			}
		}
	}
	
	private int getFreeRegister(){
		if(freeRegisters.size() > 0) {
			return freeRegisters.remove(0);
		}
		else return -1;
	}
	/**
	 * @param i
	 */
	private void SpillAtInterval(int interval) {
		int spillTemp = active.get(active.size()-1);
		if(presentCFG.endPoints.get(spillTemp) > presentCFG.endPoints.get(sortedStartPoint.get(interval))){
			registerAllotted.put(sortedStartPoint.get(interval), registerAllotted.get(spillTemp));
			registerAllotted.remove(spillTemp);
			locationOnStack.put(spillTemp,stackLocation++);
			active.remove(active.indexOf(spillTemp));
			active.add(sortedStartPoint.get(interval));
			sortActive();
		}
		else {
			locationOnStack.put(spillTemp,stackLocation++);
		}
	}

	/**
	 * @param i
	 */
	private void ExpireOldIntervals(int interval) {
		for(int j = 0 ; j < active.size(); j++){
			if(presentCFG.endPoints.get(active.get(j)) >= presentCFG.startPoints.get(sortedStartPoint.get(interval))){
				return;
			}
			addFreeRegister(registerAllotted.get(active.get(j)));
			active.remove(j);
			j = j-1;
			sortActive();
		}
	}

	/**
	 * @param integer
	 */
	private void addFreeRegister(int i) {
		freeRegisters.add(i);
		Collections.sort(freeRegisters);
	}

	/* ----- The code for sorting a hashmap is inspired from Stack Overflow-------- */
	public LinkedHashMap<Integer, Integer> sortHashMap(HashMap<Integer, Integer> passedMap) {
	    List<Integer> mapKeys = new ArrayList<Integer>(passedMap.keySet());
	    List<Integer> mapValues = new ArrayList<Integer>(passedMap.values());
	    LinkedHashMap<Integer, Integer> sortedMap = new LinkedHashMap<Integer, Integer>();

	    Collections.sort(mapValues);
	    Collections.sort(mapKeys);

	    Iterator<Integer> it$ = mapValues.iterator();
	    while (it$.hasNext()) {
	        Object val = it$.next();
	        Iterator<Integer> keyIt = mapKeys.iterator();
	        while (keyIt.hasNext()) {
	            Object key = keyIt.next();
	            int comp1 = Integer.parseInt(passedMap.get(key).toString());
	            int comp2 = Integer.parseInt(val.toString());
	            if (comp1 == comp2) {
	                passedMap.remove(key);
	                mapKeys.remove(key);
	                sortedMap.put((Integer) key, (Integer) val);
	                break;
	            }
	        }
	    }
	    return sortedMap;
	}	
	/*-------------------------------------------------------------------------*/
	
	public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() ) {
    	 return n.node.accept(this);
      }
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n) {
      R _ret=null;
      n.f0.accept(this);
      currentProcedure = n.f0.tokenImage;
      presentCFG = allCFGs.get(currentProcedure);
      registerAllotted = registerAllocation.get(currentProcedure);
      locationOnStack = stackAllocation.get(currentProcedure);
      System.out.printf("MAIN [ 0 ] [ " + (presentCFG.maxCallerSaveRegisters + presentCFG.noOfCalleeSaveRegisters + locationOnStack.values().size()+ presentCFG.maxParamsOnStack )+ " ] " +"[ "  + presentCFG.maxParams + " ]\n");
      n.f1.accept(this);
      n.f2.accept(this);
      System.out.println("END ");
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n) {
      R _ret=null;
      //n.f0.accept(this);
      System.out.println();
      presentInstructionNumber = 0;
      currentProcedure = n.f0.f0.tokenImage;
      presentCFG = allCFGs.get(currentProcedure);
      locationOnStack = stackAllocation.get(currentProcedure);
      registerAllotted = registerAllocation.get(currentProcedure);
      System.out.printf(n.f0.f0.tokenImage + " ");
      n.f1.accept(this);
      System.out.printf(n.f1.tokenImage + " ");
      n.f2.accept(this);
      n.f3.accept(this);
      System.out.printf(n.f3.tokenImage+ " ");
      int itsParamsSizeOnStack = presentCFG.itsParamsSize - 4;
      if(itsParamsSizeOnStack < 0) itsParamsSizeOnStack = 0;
      System.out.printf("[ " + (itsParamsSizeOnStack + presentCFG.maxCallerSaveRegisters + presentCFG.noOfCalleeSaveRegisters + locationOnStack.values().size() + presentCFG.maxParamsOnStack) + " ] " + "[ "  + presentCFG.maxParamsOnStack + " ]\n");
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.println("NOOP ");
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.println("ERROR ");
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf("CJUMP ");
      n.f1.accept(this);
      n.f2.accept(this);
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf("JUMP ");
      n.f1.accept(this);
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf("HSTORE ");
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf("HLOAD ");
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);

      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n) {
      R _ret=null;
      
      if(!(n.f2.f0.choice instanceof Call)){
	      n.f0.accept(this);
	      System.out.printf("MOVE ");
	      n.f1.accept(this);
	      boolean flag = true;
	      if(n.f2.f0.choice instanceof SimpleExp){
	    	  SimpleExp node = (SimpleExp)n.f2.f0.choice;
	    	  if(node.f0.choice instanceof Label){
	    		  flag = false;
	    		  Label l = (Label)node.f0.choice;
	    		  System.out.printf(l.f0.tokenImage);
	    	  }
	      }
	      
	      if(flag == true){
	    	  n.f2.accept(this);
	    	  n.f0.accept(this);
	      }
      }
      else {
    	  n.f2.accept(this);
    	  n.f0.accept(this);
    	  System.out.printf("MOVE ");
    	  n.f1.accept(this);
    	  System.out.printf("v0 ");
      }
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf("PRINT ");
      if(n.f1.f0.choice instanceof Label){
		  Label l = (Label)n.f1.f0.choice;
		  System.out.println(l.f0.tokenImage);
	  }
      else n.f1.accept(this);
      //TODO : Handle Simple Expression.
      System.out.println();
      presentInstructionNumber++;
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n) {
      R _ret=null;
      n.f0.accept(this);
      StatementNode stmt = presentCFG.blocks.get(presentInstructionNumber);
      int i = 0;
      for(int toStore : presentCFG.toStoreAndLoadCalleeSaveRegisters){
    	  System.out.println("ASTORE SPILLEDARG " + (presentCFG.maxParamsOnStack + (i++)));
      }
      for(int i = 0; i < stmt.liveIn.size(); i++){
    	if(stmt.liveIn.get(i) < 4) {
	    	if(registerAllotted.containsKey(stmt.liveIn.get(i))){
	    		System.out.println("MOVE "+ registers[registerAllotted.get(stmt.liveIn.get(i))] + " a"+ stmt.liveIn.get(i));
	    	}
	    	else{
	    		//Spilled case : TODO
	    	}
    	}
    	else{
    		if(registerAllotted.containsKey(stmt.liveIn.get(i))){
    			System.out.println("ALOAD " + "v1" + " SPILLEDARG "+ (stmt.liveIn.get(i)-4));
	    		System.out.println("MOVE "+ registers[registerAllotted.get(stmt.liveIn.get(i))] + " v1 ");
	    	}
	    }
      }
      //TODO : Save all the callee save registers
      n.f1.accept(this);
      n.f2.accept(this);
      System.out.printf("MOVE v0 ");
      n.f3.accept(this);
      // TODO : Restore Callee save registers.
      System.out.println("\nEND ");
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n) {
      R _ret=null;
      noOfSpillTemps = 0;
      int numberOfParameters = n.f3.size();
      Vector<Node> params = n.f3.nodes;
      StatementNode stmt = presentCFG.blocks.get(presentInstructionNumber);
      for(int i = 0 ; i < stmt.liveOut.size(); i++) {
    	  if(registerAllotted.containsKey(stmt.liveOut.get(i))){
    		  if(registerAllotted.get(stmt.liveOut.get(i)) < 10){
    			  System.out.println("ASTORE SPILLEDARG " + (noOfSpillTemps + i) +" "+ registers[registerAllotted.get(stmt.liveOut.get(i))] + " ");
    		  }
    	  }
      }
      // TODO : ASTORE : 
   
      if(numberOfParameters < 4){
    	  for(int i = 0 ; i < numberOfParameters; i++){
    		  Temp tmp = (Temp) params.get(i);
    		  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    		  if(registerAllotted.containsKey(tempNo)){
    			  System.out.println("MOVE a"+ i + " " + registers[registerAllotted.get(tempNo)]);
    		  }
    		  else {
    			  //TODO : Spilled case
    		  }
    	  }
      }
      else {
    	  for(int i = 0 ; i < 4; i++){
    		  Temp tmp = (Temp) params.get(i);
    		  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    		  if(registerAllotted.containsKey(tempNo)){
    			  System.out.println("MOVE a"+ i + " " + registers[registerAllotted.get(tempNo)]);
    		  }
    		  else {
    			  //TODO : Spilled case
    		  }
    	  }
    	  for(int i = 4; i < numberOfParameters; i++){
    		  Temp tmp = (Temp) params.get(i);
    		  int tempNo = Integer.parseInt(tmp.f1.f0.tokenImage);
    		  if(registerAllotted.containsKey(tempNo)){
    			  System.out.println("PASSARG "+ (i-3) + " " + registers[registerAllotted.get(tempNo)]);
    		  }
    		  else {
    			  //TODO : Spilled case
    		  }
    	  }
      }
      n.f0.accept(this);
      System.out.printf("CALL ");
      n.f1.accept(this);
      System.out.println();
      n.f2.accept(this);
      //n.f3.accept(this);
      n.f4.accept(this);
      // TODO : ALOAD
      for(int i = 0 ; i < stmt.liveOut.size(); i++) {
    	  if(registerAllotted.containsKey(stmt.liveOut.get(i))){
    		  if(registerAllotted.get(stmt.liveOut.get(i)) < 10){
    			  System.out.println("ALOAD " + registers[registerAllotted.get(stmt.liveOut.get(i))] + " SPILLEDARG " + (noOfSpillTemps + i) + " ");
    		  }
    	  }
      }
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf("HALLOCATE ");
      n.f1.accept(this);
      // TODO : Handle types for SimpleExpression
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      // TODO : Handle types for SimpleExpression
      return _ret;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n) {
      R _ret=null;
      n.f0.accept(this);
      if(n.f0.which == 0) System.out.printf("LT ");
      else if(n.f0.which == 1) System.out.printf("PLUS ");
      else if(n.f0.which == 2) System.out.printf("MINUS ");
      else if(n.f0.which == 3) System.out.printf("TIMES ");
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n) {
      R _ret=null;
      n.f0.accept(this);
      //n.f1.accept(this);
      if(registerAllotted.keySet().contains(Integer.parseInt(n.f1.f0.tokenImage))){
    	  String register = registers[registerAllotted.get(Integer.parseInt (n.f1.f0.tokenImage))];
    	  System.out.printf(register + " ");
      }
      else {
    	  //TODO : Position on the stack as it is being spilled.
    	  System.out.println("SPILLED?" + n.f1.f0.tokenImage);
    	  System.out.println("Entry Set : " + locationOnStack.entrySet());
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf(n.f0.tokenImage + " ");
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n) {
      R _ret=null;
      n.f0.accept(this);
      System.out.printf(currentProcedure + "_" + n.f0.tokenImage + " ");
      return _ret;
   }

}
